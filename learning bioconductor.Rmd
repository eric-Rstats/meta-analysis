---
title: "learning bioconductor"
author: "Eric Yang"
documentclass: ctexart
output:
  rticles::ctex:
    fig_caption: yes
    #number_sections: yes
    #toc: yes
classoption: "hyperref,"
---

# learning this book

《Bioinfomatics and computational biology solutions using R and Bioconductor》

## 2. 预处理 High-density Oligonucleotide Arrays

### 2.1 原理与扫盲

#### 文件与AffyBatch对象
+ Affymetrix就是HOA，由于此类芯片有多个probe，因此预处理(preprocessing)显得格外重要；一个gene用11-20个probe来检测

+ PM: 与目标gene的转录子配对，但别的mRNA也可能会与其配对
+ MM：one base mismatch 
+ probe pair: a unit with PM and its MM
+ affyID: identification for a probe set(a gene or a fraction of a gene)
+ probe pair set:PMs and MMs 对应于同一affyID
+ CEL: import the cel files using `affy`包,转化为`AffyBatch`对象
```{r}
library(affy)

```

+ CDF files: contain the information relating probe pair sets to locations on the array.包含信息->probe属于哪一个probesets，以及哪些是PM和MM

+ AffyBatch对象：一个s4 object，包含有如下slots：
 + cdfName: 一个character，包含CDF file的信息
 
 + nrow，ncol：array的维度
 
 + assayData: 包含raw data的object，里面有expression矩阵
 
 + phenoData: 一个AnnotatedDataFrame object,用来储存phenodata的信息
 
 + annotation: character,表示用来做annotation的信息
 
 + featureData: Object of class AnnotatedDataFrame containing feature-level (e.g., probeset-level) information
 
 + experimentData: Object of class "MIAME" containing experiment-level information

```{r,}
library(affydata)
data(Dilution)

pm(Dilution, '1001_at')[1:3,]

matplot(pm(Dilution, '1001_at'), type = 'l', xlab = "Probe No.", ylab = "PM Probe intensity")

matplot(t(pm(Dilution, '1001_at')), type = 'l', xlab = "Array No.", ylab = "PM Probe intensity")
```


#### MA-plot：用来比较两个芯片之间的差异

+ M: $M_j=Y_{2,j}-Y_{1,j}$;当y是log后的值时，M可以理解为log fold change
+ A: $A_j=(Y_{2,j}+Y_{1,j})/2$;A可以理解为average log intensity

+ affy包中MAplot的两种函数：
 + `MAplot`: 以中位数作为reference,关于每一个array绘图
 + `mva.pairs`: 绘制所有pair-wise，就会产生一个类似于相关矩阵的图

```{r}
mva.pairs(Dilution@assayData$exprs)

MAplot(Dilution)
```


蓝线表示的是M=0，而红线则表示局部多项式回归(loess)的结果，倘若基因间没有明显差异，红线应该较为接近蓝线。


### 2.2 Background adjustment and normalization

#### 2.2.1 Background adjustment

+ RMA convolution: PM will be corrected

```{r}
Dilution.bg.rma <- bg.correct(Dilution, method = 'rma')
```

+ MAS 5.0 : correct both PM and MM

```{r}
Dilution.bg.mas <- bg.correct(Dilution, method = 'mas')

```

+ Ideal mismatch :很多时候PM-MM为负值了，这就不能再接下去计算；计算IM对PM进行调整

#### 2.2.2 normalization

通过标准化来消除各个array之间的差异，让他们可以进行比较；

+ scaling: 选定一个baseline array，其余array均scaled成和它一样的均值；此处的均值计算时是使用截尾均值，头尾2%

baseline trimmed mean : $\tilde{X}_j$
column i trimmed mean : $\tilde{X}_i$

每一个y值 $Y_{ik}=Y_{ik}*\frac{\tilde{X}_j}{\tilde{X}_i}$


```{r}
Dilution.norm.scale <- normalize(Dilution, method = "constant")
```


+ Non-linear methods:
```{r}
Dilution.norm.nl <- normalize(Dilution, method = "invariantset")
```

+ Quantile normalization:

```{r}
Dilution.norm.quantile <- normalize(Dilution, method = "quantiles")
```

+ Cyclic loess:
```{r}
Dilution.norm.loess <- normalize(Dilution, method = "loess")
```

+ contrast normalization:
```{r}
Dilution.norm.contrast <- normalize(Dilution,method = "contrast")
```

#### 2.2.3 vsn
*vsn* 整合background correction and normalization
```{r}
library(vsn)
Dil.vsn <- normalize(Dilution, method = 'vsn')
```

### 2.3 Summarization
这是一个将probeset中多个probe的intensity转化为expression value的过程；
同时将`AffyBatch`对象转化为`exprSet`对象。

#### 2.3.1 expresso

```{r}
normalize.methods(Dilution) # 所有normalize的methods
pmcorrect.methods()
bgcorrect.methods()
express.summary.stat.methods()
```

在expresso函数中，可以在arguments中向后声明以上的这些方法。例如：
```{r}
eset <- expresso(Dilution, bgcorrect.method = 'rma', normalize.method = 'constant', pmcorrect.method = "pmonly", summary.method = "avgdiff")
```

上面依次是，background adjustment 使用rma，normalize使用的是scaling，pmcorrect的方法是pmonly，summary的方法是averaging

#### 2.3.2 threestep
区别：expresso不会取log2，threestep会取log2

```{r, eval=FALSE}
library(affyPLM)
eset <- threestep(Dilution, background.method = "IdealMM", normalize.method = "quantile", summary.method = "tukey.biweight")
```

#### 2.3.3 RMA

convolution background correction->quantile normalization->summarizatoin using median polish algorithm

```{r,eval=FALSE}
eset <- rma(Dilution)
```

这个结果已经取过log2了
`justRMA`将ReadAffy和rma函数整合起来了，会节省一些内存

#### 2.3.4 GCRMA

```{r}
library(gcrma)
Dil.expr <- gcrma(Dilution)
```

#### 2.3.5 affypdnn
```{r,eval=FALSE}
library("affypdnn")
```

### 2.4 Assessing preprocessing methods
如何决定使用何种预处理方法的组合很重要！

```{r}
library(affycomp)
data("dilution.phenodata")
data("spikein.phenodata")
data("hgu133a.spikein.phenodata")

```

## 3. quality assessment
```{r}
library(affy)
library(ALLMLL)
data(MLL.B)
data <- MLL.B[,c(2,1,3:5,14,6,13)]
sampleNames(data) <- letters[1:8]
```

### 3.1 exploratory data analysis

利用灰度图进行探索性分析
```{r}
palette.gray <- c(rep(gray(0:10/10), times = seq(1, 41, by = 4)))
image(data[, 1], transfo = function(x) x, col = palette.gray) # raw intensity
image(data[, 1], col = palette.gray) # log intensity
```

#### 3.1.1 multi-array approches
+ 利用boxplot查看芯片质量
```{r}
library(RColorBrewer)
cols <- brewer.pal(8, "Set1")
boxplot(data, col = cols)

```

+ 利用histogram查看芯片质量
```{r}
hist(data, col = cols, lty = 1, xlab = "Log (base 2) intensities")
legend(12, 1, letters[1:8], lty = 1, col = cols)
```

+ MA plot
```{r}
par(mfrow = c(2,4))
MAplot(data, cex=0.75)
mtext("M", 2, outer = T)
mtext("A", 1, outer = T)
```

### 3.2 Affymetrix quality assessment metrics

```{r}
library(simpleaffy)
data.qc <- qc(data)
data.qc@average.background  # average background
data.qc@scale.factors #scaled factors
data.qc@percent.present
ratios(data.qc)[,1:2]
```

### 3.3 RNA degradation

### 3.4 Probe level models

















## 实践：利用affy包进行preprocessing
```{r}
library(affy)
# background correaction methods
bgcorrect.methods()
# normalize methods
normalize.AffyBatch.methods()
# PM correct methods
pmcorrect.methods()
# summarization methods
express.summary.stat.methods()
```


1.读取路径中的所有cel文件
```{r}
pwd <- "E:/生物统计/meta-analysis/testdata/1332168401_copd_CELfiles/copd_data"
rawdata <- ReadAffy(celfile.path = pwd)
```

2. 预处理：background correction,normalization,probe specific correction,summarization

+ `expresso`: 可以在
```{r}
eset <- expresso(rawdata, bgcorrect.method = 'rma', 
                 normalize.method = "qspline",
                 pmcorrect.method = "pmonly", 
                 summary.method = "mas")
```

至于存在的方法有
```{r}
bgcorrect.methods()
normalize.methods()
pmcorrect.methods()
express.summary.stat.methods()
```

+ mas 5.0
```{r,eval=FALSE}
eset <- mas5(rawdata)
```

+ li wong MBEI (dchip)
```{r,eval=FALSE}
eset <- expresso(Dilution, normalize.method="invariantset",
                  bg.correct=FALSE,
                  pmcorrect.method="pmonly",summary.method="liwong")
```

+ RMA:Robust Multichip Average

Currently the rma function implements RMA in the following manner
1. Probe specific correction of the PM probes using a model based on observed in-
tensity being the sum of signal and noise
2. Normalization of corrected PM probes using quantile normalization (Bolstad et al.,
2003)
3. Calculation of Expression measure using median polish.

```{r}
eset <- rma(rawdata)
eset@assayData$exprs[1:5,1:5]
```

由上面的输出结果可以看出表达矩阵的列是一个芯片，行是affyID

3. quality control


```{r}
MAplot(rawdata, pairs = T, plot.method = "smoothScatter")
```


3.1 accessing PM and MM Data

```{r}
index <- c(1,2,3,5)
pm(rawdata)[index,1:5]
mm(rawdata)[index,1:5]

```

probenames表示的是探针所属的probe set的编号,一个probe set中可能有多个探针如:
```{r}
unique(probeNames(rawdata))[1:5]
```

提取某一个probe set intensity
```{r}
gn <- geneNames(rawdata)
pm(rawdata, gn[10])[,1:5]
```


3.2 histograms, Images, boxplots

histograms
```{r}
hist(rawdata[,1:2])
```

boxplot
```{r}
boxplot(rawdata,col=1:40)
```


3.3 RNA degration plot

```{r}
deg <- AffyRNAdeg(rawdata)
names(deg)
summaryAffyRNAdeg(deg)
plotAffyRNAdeg(deg)

```


4. Classes: affy中的object类型

4.1 AffyBatch


4.2 ProbeSet
```{r}
gn <- featureNames(Dilution)
ps <- probeset(Dilution, gn[1:2])
```

+ `ps`就成为了一个probeset object,这里是两个probeset object的list
```{r}
class(ps)
class(ps$`100_g_at`)
show(ps[[1]])
```

```{r}

```

5. location to probeset mapping

```{r}
data("SpikeIn")
pms <- pm(SpikeIn)
mms <- mm(SpikeIn)
par(mfrow=c(1,2))
concentration <- matrix(as.numeric(sampleNames(SpikeIn)), 20, 12, byrow = T)
matplot(concentration, pms, log="xy", main = "PM", ylim = c(30,20000))
lines(concentration[1,], apply(pms, 2, mean), lwd = 3)
matplot(concentration, mms, log="xy", main = "MM", ylim = c(30,20000))
lines(concentration[1,], apply(mms, 2, mean), lwd = 3)

```

```{r}
Index <- pmindex(Dilution) # 返回的是一个list，每一个list是一个probe set集
names(Index)[1:2]
Index$`100_g_at`

pmindex(Dilution, genenames = c("1000_at", "1001_at"))
```








